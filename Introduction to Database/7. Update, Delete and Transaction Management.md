### Update, Delete and Transaction Management
- UPDATE
  - Changes the value of existing data.
  - For example, at the end of semester, change the mark and grade from null to the actual mark and grade.
  - UPDATE table SET column=(subquery)[, column=value, ...][WHERE condition];
- DELETE
  - Removing data from the database
  - DELETE FROM table [WHERE condition];
- Transactions Properties
  - Atomicity
    - all database operations (SQL requests) of a transaction must be entirely completed or entirely aborted
  - Consistency
    - it must take the database from one consistent state to another
  - Isolation
    - it must not interfere with other concurrent transactions
    - data used during execution of a transaction cannot be used by a second transaction until the first one is completed
  - Durability
    - once completed the changes the transaction made to the data are durable, even in the event of system failure
- Transaction Management
  - Follows the ACID properties
  - Transaction boundaries
    - Start
      - first SQL statement is executed (eg. Oracle)
      - Some systems have a BEGIN WORK type command
    - End
      - COMMIT or ROLLBACK
  - Concurrency Management
  - Restart and Recovery
- Concurrency
  - Serial and Interleaved transactions
  - <img width="598" alt="Screen Shot 2022-02-16 at 11 33 29 PM" src="https://user-images.githubusercontent.com/24580756/154298865-21850c4e-d587-4874-8161-422b6b6febe7.png">
- Lock Granularity
  - Granularity of locking refers to the size of the units that are, or can be, locked. Locking can be done at
    - database level
    - table level
    - page level
    - record level
      - Allows concurrent transactions to access different rows of the same table, even if the rows are located on the same page.
    - attribute level
      - Allows concurrent transactions to access the same row, as long as they require the use of different attributes within that row.
- Lock Types
  - Shared lock. Multiple processes can simultaneously hold shared locks, to enable them to read without updating.
    - if a transaction Ti has obtained a shared lock (denoted by S) on data item Q, then Ti can read this item but not write to this item
  - Exclusive lock. A process that needs to update a record must obtain an exclusive lock. Its application for a lock will not proceed until all current locks are released.
    - if a transaction Ti has obtained an exclusive lock (denoted X) on data item Q, then Ti can both read and write to item Q
- Exclusive Locks - Example 1
  - <img width="614" alt="Screen Shot 2022-02-16 at 11 38 26 PM" src="https://user-images.githubusercontent.com/24580756/154299923-a468eba6-51aa-48c0-99b0-9a140162f827.png">
- Shared Locks - Example 2
  - <img width="656" alt="Screen Shot 2022-02-16 at 11 38 57 PM" src="https://user-images.githubusercontent.com/24580756/154300042-3d3ed161-9ffa-4d56-8798-5e8a3f824fb9.png">
- Wait-For-Graph (WFG)
  - <img width="667" alt="Screen Shot 2022-02-16 at 11 39 33 PM" src="https://user-images.githubusercontent.com/24580756/154300184-3f45ace8-8816-4c27-9d89-e91ac984164b.png">
- Lock - Problem
  - Deadlock
    - Scenario:
      - Transaction 1 has an exclusive lock on data item A, and requests a lock on data item B.
      - Transaction 2 has an exclusive lock on data item B, and requests a lock on data item A.
    - Result: Deadlock, also known as “deadly embrace”.
      - Each has locked a resource required by the other, and will not release that resource until it can either commit, or abort. Unless some “referee” intervenes, neither will ever proceed.
- Dealing with Deadlock
  - Deadlock prevention
    - A transaction must acquire all the locks it requires before it updates any record.
    - If it cannot acquire a necessary lock, it releases all locks, and tries again later.
  - Deadlock detection and recovery
    - Detection involves having the Lock Manager search the Wait-for tables for lock cycles.
    - Resolution involves having the Lock Manager force one of the transactions to abort, thus releasing all its locks.
  - If we discover that the system is in a state of deadlock, some of the transactions causing the deadlock must be aborted. Choosing which transaction to abort is called as victim selection.
  - The algorithm for victim selection should generally avoid selecting transactions that have been running for a long time and that have performed many updates, and should try instead to select transactions that have not made any changes or that are involved in more than one deadlock cycle in the wait-for graph.
- Database Restart and Recovery
  - Restart
    - Soft crashes
      - loss of volatile storage, but no damage to disks. These necessitate restart facilities.
  - Recovery
    - Hard crashes
      - hard crashes - anything that makes the disk permanently unreadable. These necessitate recovery facilities.
  - Requires transaction log.
- Transaction Log
  - The log, or journal, tracks all transactions that update the database. It stores
    - For each transaction component (SQL statement)
      - Record for beginning of transaction
      - Type of operation being performed (update, delete, insert)
      - Names of objects affected by the transaction (the name of the table)
      - “Before” and “after” values for updated fields
      - Pointers to previous and next transaction log entries for the same transaction
      - The ending (COMMIT) of the transaction
      - The log should be written to a multiple separate physical devices from that holding the database, and must employ a force-write technique that ensures that every entry is immediately written to stable storage, that is, the log disk or tape.
- Sample Transaction Log
  - <img width="557" alt="Screen Shot 2022-02-16 at 11 44 09 PM" src="https://user-images.githubusercontent.com/24580756/154301157-d016af87-3170-4926-84d3-b4d962cce751.png">
- Checkpointing
  - Although there are a number of techniques for checkpointing, the following explains the general principle. A checkpoint is taken regularly, say every 15 minutes, or every 20 transactions.
  - The procedure is as follows:
    - Accepting new transactions is temporarily halted, and current transactions are suspended.
    - Results of committed transactions are made permanent (force-written to the disk).
    - A checkpoint record is written in the log.
    - Execution of transactions is resumed.
- Write Through Policy
  - The database is immediately updated by transaction operations during the transaction's execution, before the transaction reaches its commit point
  - If a transaction aborts before it reaches its commit point a ROLLBACK or UNDO operation is required to restore the database to a consistent state
  - The UNDO (ROLLBACK) operation uses the log before values
- Restart Procedure for Write Through
  - Once the cause of the crash has been rectified, and the database is being restarted:
    - The last checkpoint before the crash in the log file is identified. It is then read forward, and two lists are constructed:
    - a REDO list containing the transaction-ids of transactions that were committed.
    - and an UNDO list containing the transaction-ids of transactions that never committed
  - The database is then rolled forward, using REDO logic and the after-images and rolled back, using UNDO logic and the before-images. 
- An alternative - Deferred Write
  - The database is updated only after the transaction reaches its commit point
  - Required roll forward (committed transactions redone) but does not require rollback
- Recovery
  - A hard crash involves physical damage to the disk, rendering it unreadable. This may occur in a number of ways:
    - Head-crash. The read/write head, which normally “flies” a few microns off the disk surface, for some reason actually contacts the disk surface, and damages it.
    - Accidental impact damage, vandalism or fire, all of which can cause the disk drive and disk to be damaged.
  - After a hard crash, the disk unit, and disk must be replaced, reformatted, and then re-loaded with the database.
- Backup
  - A backup is a copy of the database stored on a different device to the database, and therefore less likely to be subjected to the same catastrophe that damages the database. (NOTE: A backup is not the same as a checkpoint.)
  - Backups are taken say, at the end of each day’s processing.
  - Ideally, two copies of each backup are held, an on-site copy, and an off-site copy to cater for severe catastrophes, such as building destruction.
  - Transaction log – backs up only the transaction log operations that are not reflected in a previous backup of the database.
- Recovery
  - Rebuild the database from the most recent backup. This will restore the database to the state it was in say, at close-of-business yesterday.
  - REDO all committed transactions up to the time of the failure - no requirement for UNDO
